import { URLSearchParams } from 'url';
import { ApiClient } from './apiClient';
import { mockMemes, mockImages, mockRedditPosts } from '../mocks/memeMocks';

export interface MemeServiceConfig {
  imgflipUrl: string;
  imgflipUsername?: string;
  imgflipPassword?: string;
  unsplashUrl: string;
  unsplashAccessKey?: string;
  redditUrl: string;
  useMockFallback: boolean;
}

export interface Meme {
  id: string;
  name: string;
  url: string;
  width: number;
  height: number;
  box_count?: number;
}

export interface Image {
  id: string;
  description: string;
  urls: {
    regular: string;
    small: string;
  };
  user: {
    name: string;
    username: string;
  };
  alt_description?: string;
}

export interface RedditPost {
  title: string;
  url: string;
  author: string;
  score: number;
  subreddit: string;
  created: number;
  permalink: string;
}

export class MemeService {
  private imgflipClient: ApiClient;
  private unsplashClient: ApiClient | null;
  private redditClient: ApiClient;
  private config: MemeServiceConfig;

  constructor(config: MemeServiceConfig) {
    this.config = config;
    this.imgflipClient = new ApiClient({ baseURL: config.imgflipUrl });
    
    this.unsplashClient = config.unsplashAccessKey
      ? new ApiClient({
          baseURL: config.unsplashUrl,
          headers: {
            'Authorization': `Client-ID ${config.unsplashAccessKey}`
          }
        })
      : null;
    
    this.redditClient = new ApiClient({ baseURL: config.redditUrl });
  }

  // Keyless inspiration image using Picsum
  private buildPicsumImage(seed?: string): Image {
    const s = seed || Math.random().toString(36).slice(2);
    return {
      id: `picsum-${s}`,
      description: 'Random inspiration image (Picsum)',
      urls: {
        regular: `https://picsum.photos/seed/${s}/1200/800`,
        small: `https://picsum.photos/seed/${s}/600/400`
      },
      user: { name: 'Picsum', username: 'picsum' },
      alt_description: 'Random image generated by Picsum'
    };
  }

  async captionMeme(options: {
    templateId: string;
    captions: string[];
    font?: string;
    maxFontSize?: string;
  }): Promise<{ url: string; pageUrl?: string }> {
    const { templateId, captions, font, maxFontSize } = options;

    if (!this.config.imgflipUsername || !this.config.imgflipPassword) {
      // Keyless built-in fallback using dummyimage.com (no API key required)
      const text = encodeURIComponent((captions || []).filter(Boolean).join('\n') || 'Inspire');
      return { url: `https://dummyimage.com/800x600/111/eeeeee.png&text=${text}` };
    }

    const form = new URLSearchParams({
      template_id: templateId,
      username: this.config.imgflipUsername,
      password: this.config.imgflipPassword,
      text0: captions[0] ?? '',
      text1: captions[1] ?? ''
    });

    captions.slice(2).forEach((caption, index) => {
      form.append(`text${index + 2}`, caption ?? '');
    });

    if (font) form.append('font', font);
    if (maxFontSize) form.append('max_font_size', maxFontSize);

    try {
      const response = await this.imgflipClient.post<{
        success: boolean;
        data?: { url: string; page_url?: string };
        error_message?: string;
      }>(
        '/caption_image',
        form,
        { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
      );

      if (response.success && response.data?.url) {
        return { url: response.data.url, pageUrl: response.data.page_url };
      }

      throw new Error(response.error_message || 'Unknown Imgflip error');
    } catch (error) {
      // On error, return a keyless dummy image with overlaid text.
      const text = encodeURIComponent((captions || []).filter(Boolean).join('\n') || 'Inspire');
      return { url: `https://dummyimage.com/800x600/111/eeeeee.png&text=${text}` };
    }
  }

  /**
   * Get popular meme templates
   */
  async getMemes(): Promise<Meme[]> {
    try {
      const response = await this.imgflipClient.get<{ success: boolean; data: { memes: Meme[] } }>('/get_memes');
      return response.data.memes;
    } catch (error) {
      console.warn('[MemeService] Failed to fetch memes, using mock data');
      if (this.config.useMockFallback) {
        return mockMemes;
      }
      throw error;
    }
  }

  /**
   * Get random inspirational image
   * @param query Search query for images (e.g., 'music', 'energy')
   */
  async getRandomImage(query: string = 'music'): Promise<Image | null> {
    if (!this.unsplashClient) {
      // Provide a keyless random image via Picsum
      return this.buildPicsumImage(`${query}-${Date.now().toString(36)}`);
    }

    try {
      const image = await this.unsplashClient.get<Image>('/photos/random', {
        query,
        orientation: 'landscape'
      });
      return image;
    } catch (error) {
      console.warn('[MemeService] Failed to fetch random image, using Picsum fallback');
      return this.buildPicsumImage(`${query}-${Math.random().toString(36).slice(2)}`);
    }
  }

  /**
   * Search images by keyword
   * @param query Search query
   * @param perPage Number of results per page (default: 10)
   */
  async searchImages(query: string, perPage: number = 10): Promise<Image[]> {
    if (!this.unsplashClient) {
      // Return a small set of Picsum-based images to simulate search results
      const results: Image[] = [];
      for (let i = 0; i < Math.min(Math.max(perPage, 1), 20); i++) {
        results.push(this.buildPicsumImage(`${query}-${i}-${Date.now().toString(36)}`));
      }
      return results;
    }

    try {
      const response = await this.unsplashClient.get<{ results: Image[] }>('/search/photos', {
        query,
        per_page: perPage
      });
      return response.results;
    } catch (error) {
      console.warn('[MemeService] Failed to search images, using Picsum fallback');
      const results: Image[] = [];
      for (let i = 0; i < Math.min(Math.max(perPage, 1), 20); i++) {
        results.push(this.buildPicsumImage(`${query}-${i}-${Math.random().toString(36).slice(2)}`));
      }
      return results;
    }
  }

  /**
   * Get memes from a subreddit
   * @param subreddit Name of the subreddit (default: 'memes')
   * @param sort Sort type: 'hot', 'top', 'new' (default: 'hot')
   * @param limit Number of posts to retrieve (default: 10)
   */
  async getSubredditMemes(
    subreddit: string = 'memes',
    sort: 'hot' | 'top' | 'new' = 'hot',
    limit: number = 10
  ): Promise<RedditPost[]> {
    try {
      const response = await this.redditClient.get<{
        data: {
          children: Array<{ data: RedditPost }>;
        };
      }>(`/r/${subreddit}/${sort}.json`, { limit });

      return response.data.children.map(child => child.data);
    } catch (error) {
      console.warn('[MemeService] Failed to fetch subreddit memes, using mock data');
      if (this.config.useMockFallback) {
        return mockRedditPosts.slice(0, limit);
      }
      throw error;
    }
  }

  /**
   * Get motivational posts from r/GetMotivated
   * @param limit Number of posts (default: 5)
   */
  async getMotivationalPosts(limit: number = 5): Promise<RedditPost[]> {
    return this.getSubredditMemes('GetMotivated', 'top', limit);
  }

  // Mock data helper
  private getRandomMockImage(): Image {
    return mockImages[Math.floor(Math.random() * mockImages.length)];
  }

  private getMockCaption(templateId: string, captions: string[]): { url: string } {
    const text = encodeURIComponent((captions || []).filter(Boolean).join('\n') || templateId || 'Inspire');
    return { url: `https://dummyimage.com/800x600/111/eeeeee.png&text=${text}` };
  }
}

// Factory function to create MemeService with environment variables
export function createMemeService(): MemeService {
  const useMockFallback = process.env.USE_MOCK_FALLBACK !== 'false';
  return new MemeService({
    imgflipUrl: process.env.IMGFLIP_API_URL || 'https://api.imgflip.com',
    imgflipUsername: process.env.IMGFLIP_USERNAME,
    imgflipPassword: process.env.IMGFLIP_PASSWORD,
    unsplashUrl: process.env.UNSPLASH_API_URL || 'https://api.unsplash.com',
    unsplashAccessKey: process.env.UNSPLASH_ACCESS_KEY,
    redditUrl: process.env.REDDIT_API_URL || 'https://www.reddit.com',
    useMockFallback
  });
}
